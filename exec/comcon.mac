	TITLE COMCON - COMMAND CONTROL - THE COMMAND SETUP ROUTINES
	SUBTTL T. HASTINGS 8-2-65

;CALLED FROM COMMAND DECODER WHICH IS CALLED FROM CLOCK ROUTINE
;WITH FOLLOWING ACS SET:
;TAC= BYTE POINTER TO COMMAND STRING(SPACE OR CR AFTER COMMAND NAME)
;ITEM = JOB NUMBER
;DAT = BYTE POINTER TO LAST OUTPUT CHARACTER
;DEVDAT= ADDRESS OF DEVICE DATA BLOCK INITIATING COMMAND
;JDAT = ADDRESS OF JOB DATA AREA, = 0 IF NO JOB AREA

;UPON RETURN FROM COMMAND SETUP ROUTINE, A CR-LF IS ADDED IF
;NEEDED AND TTY IS STARTED

;SINCE THE COMMAND DECODER IS CALLED FROM THE CLOCK ROUTINE
;COMMAND SETUP ROUTINES MUST RUN TO COMPLETION QUICKLY
;IF A COMMAND FUNCTION CANNOT DO THIS, IT MUST JUST SET
;THE JOB TO A RUNABLE STATUS AND RETURN I MEDIATELY


; "IJOB" - INITIALIZE JOB
INTERNAL IJOB
EXTERNAL RADX10,JOBINI,JOBKIL,CRLF,MONJOB

IJOB:	JRST JOBINI

;PRINT JOB NUMBER

	INTERNAL PJOB
PJOB:	MOVE TAC, ITEM
	PUSHJ PDP,RADX10
	JRST CRLF

;KILL JOB(MUST HAVE CORE ASSIGNED)

	INTERNAL KJOB
KJOB:	JRST JOBKIL

; "START L" OR "START" - START AT LOC. L OR STARTING ADDRESS
INTERNAL START
EXTERNAL OCTIN,JOBSA,START1,COMERA,STARTU,CPOPJ,CPOPJ1,STARTM

START:	PUSHJ PDP,STRT
	JRST COMERA	;ERROR
	JRST STARTU	;GO SET JOB TO START(CONSOLE IN USER MO

; "STARTC L" OR  "STARTC" - START AT LOC. L(TTY IN COMMAND MODE)

INTERNAL STARTC
EXTERNAL STARTM

STARTC:	PUSHJ PDP,STRT
	JRST COMERA	;ERROR
	JRST STARTM	;FO SET JOB TO START(TTY IN COM. MODE)

;ROUTINE TO SCAN ARGUMENT

STRT:	PUSHJ PDP,OCTIN	;CONVERT OCTAL NO.
	JRST ST2	;EITHER NO NUMBER OR ERROR
	JRST ST3	;START JOB C(TAC1)

ST2:	JUMPN TAC1, CPOPJ	;NOT A NUMBER IF NON-ZERO
	HRRZ TAC1, JOBSA(JDAT)	;NO, START AT STARTING ADDRES
ST3:	HRLI TAC1, 10000	;USER MODE FLAG
	JRST CPOPJ1	;OR RETURN

; "CONT" - CONTINUE EXECUTION FROM WHERE LEFT OFF
INTERNAL CONT
EXTERNAL CONTU,CONMES,JBTSTS

CONT:	MOVSI TAC1, JERR
	TDNN TAC1, JBTSTS(ITEM)	;IS JOB ERROR BIT SET?
	JRST CONTU		;NO, GO SET JOB TO CONTINUE
CONTA:	JSP TAC,CONMES	;YES, PRINT CANT CONTINUE

	ASCIZ /CAN'T CONTINUE
/

; "CONTC" - CONTINUE EXECUTION(TTY REMAINS IN COMMAND MODE)

INTERNAL CONTC
EXTERNAL CONTM

CONTC:	MOVSI TAC1, JERR
	TDNN TAC1, JBTSTS(ITEM)	;IS JOB ERROR BIT SET?
	JRST CONTM	;NO
	JRST CONTA	;YES

; "DDT" - START EXECUTION AT DDT IN USER AREA
INTERNAL DDTGO
EXTERNAL JOBDDT,STARTU

DDTGO:	HRRZ TAC1, JOBDDT(JDAT)	;GET DDT STARTING ADDRESS
	JUMPN TAC1,DDT1	;GO START JOB IF NON-ZERO
	JSP TAC,CONMES		;ZERO, PRINT"NO DDT"

	ASCII /NO DDT
/

DDT1:	HRLI TAC1,USRMOD	;USER MODE BIT
	JRST STARTU	;GO SET TO RUN JOB
;DIGITAL MAYNARD

INTERNAL DIGITAL

DIGITAL:	JSP TAC,CONMES
	ASCIZ /HELLO
/




; "CORE  #" - ASSIGNS #*1024 WORDS OF CORE TO JOB
;   "CORE" WITH NO ARGUMENT IS EQUIVALENT TO "CORE 0"

INTERNAL CORE
EXTERNAL CORE1,DECIN,ANYRIN,CONMES,COMERA,NOTENF
EXTERNAL JOBPFI,JBTADR,CPOPJ,JOBPRT,JOBPR1,JOBZER
EXTERNAL RADX10

CORE:	PUSHJ PDP, DECIN	;GET NO. OF 1K BLOCKS
	JRST COR3		;ERROR
	SKIPN TAC,TAC1	;IS ZERO BEING ASKED FOR?
	JUMPN JDAT,JOBZER	;YES, RELEASE ALL DEVICES IF THERE WAS
	PUSHJ PDP,CORE1
	JRST COR2		;CORE NOT AVAILABLE (AC TAC = BLO CKS L
	HRRZ JDAT, JBTADR(ITEM)	;CORE GRANTED, CLEAR PART OF
	JUMPE JDAT, CPOPJ	;UNLESS ALL CORE WAS RETURNED
	SETZM JOBPRT(JDAT)		;CLEAR PART PROTECTED FROM IO
	HRLI TAC,JOBPRT(JDAT)
	HRRI TAC, JOBPR1(JDAT)
	BLT TAC, JOBPFI(JDAT)
	POPJ PDP,

COR2:	PUSHJ PDP,RADX10	;PRINT NO. OF FREE 1K BLOCKS LEFT
	JSP TAC,CONMES

	ASCIZ / FREE 1K BLOCKS LEFT, NONE ASSIGNED
/
COR3:	JUMPN TAC1, COMERA	;NOT A NO. IF NON-ZERO, APPEND "?"
	JRST NOTENF	;NOT ENOUGH ARGUMENT


; "SAVE FILE-NAME" - SAVES JOB AREA ON RETRIEVABLE DEVICE
;ONLY A SAVE OR A GET IN PROGRESS FOR EACH JOB
;NO ATTEMPT IS MADE TO SAVE DEVICE ASSIGNMENTS, ACS, OR PC
INTERNAL SAVE
EXTERNAL SAVJOB,START1,SGSET

SAVE:	MOVEI TAC1, SAVJOB	;SETUP TO RUN SAVJOB
	JRST SGSET


; "GET DEVICE:FILE-NAME" - SETS UP JOB AREA FROM RETRIEVABLE DEVICE
INTERNAL GET
EXTERNAL GETJOB

GET:	MOVEI TAC1, GETJOB	;SETUP TO RUN GET JOB
	JRST SGSET

;"ASSIGN DEV:NAME" - ASSIGNS DEV TO JOB AND GIVES IT LOGICAL NAME NAM

;TEMPORARY ACS
	T1=BUFPNT
	T=BUFWRD

INTERNAL ASSIGN
EXTERNAL CTEXT1, NOTENF, DEVLST, ASSASG, CONMES, PJOBN, ANYRDX, ERNAM
EXTERNAL CRLF, DEVLG,SYSTAP

ASSIGN:	PUSHJ PDP, CTEXT1	;GET FIRST ARGUMENT
	JUMPE TAC1, NOTENF	;NO ARGUMENT TYPED IF 0
	MOVE T1, TAC1		;SAVE DEVICE NAME
	PUSH PDP, TAC	;SAVE INPUT BYTE POINTER
	MOVEI TAC1, ASSCON	;SETUP ASSIGNED BY CONSOLE BIT
ASSN:	HLRZ DEVDAT, DEVLST
ASSG0:	CAME T1,DEVNAM(DEVDAT)	;DOES PHYSICAL NAME MATCH?
	JRST ASSG1	;NO
	PUSHJ PDP, ASSASG	;YES, TRY TO ASSIGN DEVICE
	JRST ASSER1	;ALREADY ASSIGNED TO ANOTHER JOB
	JRST ASSFIN	;ASSIGNED

ASSG1:	MOVE TAC,DEVNAM(DEVDAT)	;IS THIS THE SYSTEM TAPE?
	CAMN TAC,SYSTAP
	JRST ASSG2		;YES
	LDB T, PJOBN		;SAVE OLD JOB NUMBER FOR THIS
	TRZ TAC,-1		;COMPARE LEFT HALF ONLY
	CAMN TAC, T1
	PUSHJ PDP, ASSASG	;MATCH, TRY TO ASSIGN IT
	JRST ASSG2	;KEEP LOOKING
	JUMPE T,ASSFIN	;IF OLD JOB NUMBER 0, DEVICE PREVIOSLY

ASSG2:	HLRZ DEVDAT, DEVSER(DEVDAT)
	JUMPN DEVDAT, ASSG0
	POP PDP, TAC
	JRST NOTDEV		;PRINT NO SUCH DEVICE

;ALREADY ASSIGNED TO ANOTHER JOB

ASSER1:	POP PDP, TAC
	MOVEI TAC, ASSMS2
	PUSHJ PDP, CONMES
	MOVEI TAC1, ^D10
	LDB TAC, PJOBN
	PUSHJ PDP,ANYRDX
	JRST CRLF

ASSMS2:	ASCIZ /ALREADY ASSIGNED TO JOB /

;DEVICE ASSIGNED, GIVE IT A LOGICAL NAME

ASSFIN:	POP PDP,TAC	;RESTORE INPUT BYTE POINTER
	PUSH PDP,DEVDAT	;SAVE DDB ADDRESS
	PUSHJ PDP,CTEXT1	;GET SECOND ARG, LOGICAL DEVICE NAME
	SKIPE TAC,TAC1	;IS THERE A LOGICAL NAME SPECIFIED?
	PUSHJ PDP, DEVLG	;YES, SEE IF IT IS ALREADY IN USE
			;BY THIS USER
	JRST ASSF1		;NO
	MOVEI TAC,LOGERR	;YES, PRINT ERROR
	PUSHJ PDP,CONMES
ASSF1:	MOVE DEVDAT,(PDP)	;RESTORE DDB ADDRESS
	MOVEM TAC1,DEVLOG(DEVDAT)	;STORE IN DEVICE DATA BLOCK
	MOVSI TAC1,DVDIRIN	;CLEAR DIRECTORY IN CORE BIT
	ANDCAM TAC1,DEVMOD(DEVDAT)
	PUSHJ PDP, ERNAM	;PRINT PHYSICAL DEVICE NAME
	POP PDP, DEVDAT
	JSP TAC,CONMES

	ASCIZ / ASSIGNED
/

LOGERR:	ASCIZ /LOGICAL NAME ALREADY IN USE, /


;"DEASSIGN DEV" - DEASSIGNS DEVICE FROM CONSOLE

INTERNAL DEASSIGN, NOTDEV
EXTERNAL CTEXT1, DEVSRC, CONMES, ERNAM, DEASG, DEASTY

DEASSIGN: PUSHJ PDP, CTEXT1	;GET DEVICE NAME
	JUMPE TAC1,DEASTY	;NO ARG. IF 0, DEASSIGN ALL BUT TTY
	MOVE TAC, TAC1	;DEVICE NAME
	PUSHJ PDP, DEVSRC	;SEARCH FOR DEVICE
	JRST DEAER1	;NOT FOUND
	PUSHJ PDP, DEASG	;FOUND, DEASSIGN IT
	JRST DEAER2	;NOT PREVIOUSLY ASSIGNED
	POPJ PDP,		;DEVICE DEASSIGNED

NOTDEV:
DEAER1:	JSP TAC,CONMES	;PRINT NO SUCH DEVICE

	ASCIZ /NO SUCH DEVICE
/

DEAER2:	PUSH PDP, DEVDAT	;PRINT PHYSICAL DEVICE NAME
	PUSHJ PDP, ERNAM
	POP PDP, DEVDAT
	JSP TAC,CONMES

	ASCIZ / WASN'T ASSIGNED
/


; "ATTACH N" - ATTACH CONSOLE TO JOB N
;CHANGES ADDRESS OF TTY DEVICE DATA BLOCK STORED IN -1(PDP)
;BY THE COMMAND DECODER

INTERNAL ATTACH
EXTERNAL DECIN,TTYATT,JOBN,ERNAM,CONMES,TTYFND

ATTACH:	PUSHJ PDP,DECIN	;GET JOB NO.
	JRST ATT1		;NOT A NUMBER OR NONE SPECIFIEED
	SKIPE TAC1		;0 IS ILLEGAL
	CAIL TAC1, JOBN	;IS JOB NUMBER TOO BIG?
	JRST ATT1		;ILLEGAL JOB NUMBER
	MOVSI TAC,JNA	;HAS THIS JOB NO BEEN ASSIGNED?
	TDNN TAC,JBTSTS(TAC1)
	JRST ATT4		;NO, PRINT ERROR
	MOVE ITEM,TAC1	;JOB NUMBER TO ITEM
	PUSHJ PDP,TTYATT	;NO, ATTACH TTY
	JRST ATT2		;ERROR CANT ATTACH
	MOVEM DEVDAT,-1(PDP)	;CHANGE DEV DATA BLOCK ADDRES
	JRST TTYFND	;ATTACHED. GO SET UP OUTP. BYTE PTR.

ATT1:	JSP TAC,CONMES
	ASCIZ /ILLEGAL JOB NUMBER
/

ATT2:	PUSH PDP,DEVDAT
	PUSHJ PDP,ERNAM	;PRINT TTY DEVICE NAME
	POP PDP,TAC
	JSP TAC,CONMES
	ASCIZ / ALREADY ATTACHED
/

ATT4:	JSP TAC,CONMES
	ASCIZ /JOB NEVER WAS INITIATED
/

; "DETACH" - DETACH CONSOLE FORM JOB

INTERNAL DETACH
EXTERNAL TTYDET

DETACH:	AOS (PDP)		;SUPRESS CR-LF SO NO TTY DDB SETUP
	JRST TTYDET	;GO DETACH TTY

	END,
