	TITLE IOCSS - IO COMMON SYSTEM SUBROUTINES
	SUBTTL 8-15-65

	EXTERNAL CLOSE1,DEVLST,ERROR,JBTADR
	EXTERNAL JOB,JOBFF,RELEA1,USRJDA,WAIT1,CLDS,CLEN
	EXTERNAL PJOBN,CPOPJ1,PIOMOD,CPOPJ,CPOPJ2
	EXTERNAL SCNOFF,SCNON

,DEC 06 00 EX COM L PT PRE 01 ADVBFE
,H. R. MORSE	64-12-26
,CALLING SEQUENCE
,	PUSHJ PDP,ADVBFE
,	EXIT1		RETURN IF NEXT BUFFER IS EMPTY
,	EXIT2		RETURN IF NEXT BUFFER IS FULL
,CLEARS THE USE BIT (IOUSE:=0) OF THE BUFFER POINTED TO BY THE
,OUTPUT BUFFER ADDRESS (DEVOAD) OF THE CURRENT DEVICE DATA BLOCK
,AND ADVANCES THE BUFFER ADDRESS TO THE NEXT BUFFER IN THE RING.
,UPON RETURN, SKIPS IF THE NEXT BUFFER IS FULL.
,MONITOR INTERFACE
,	STORAGE:	6
,	SYMBOLS SET/USED:
,	    ACCUMULATORS:	DEVDAT  U
,			PDP     S/U
,			TAC     S/U
,	    DEVICE DATA BLOCK:	DEVOAD S/U
,	    JOB BUFFER HEADER:	IOUSE  S/U
	INTERN ADVBFE
ADVBFE:	ADRCHK DEVOAD(DEVDAT)
	HRLZI TAC,IOUSE;	IOUSE:=0
	ANDCAB TAC,@DEVOAD(DEVDAT)
	HRRM TAC,DEVOAD(DEVDAT); DEVOAD 18-35:=NEXT BUFFER ADDRESS
	SKIPGE @DEVOAD(DEVDAT);	IS IOUSE=0?
	AOS (PDP);		EXIT2. BUFFER IS FULL
	POPJ PDP,;	EXIT1. BUFFER IS EMPTY

,DEC 06 00 EX COM L PT PRE 01 ADVBFF
,H. R. MORSE	64-12-26
,CALLING SEQUENCE
,	PUSHJ PDP,ADVBFF
,	EXIT1		RETURN IF NEXT BUFFER IS FULL
,	EXIT2		RETURN IF NEXT BUFFER IS EMPTY
,SETS THE USE BIT (IOUSE:=1) OF THE BUFFER POINTED TO BY THE
,INPUT BUFFER ADDRESS (DEVIAD) OF THE CURRENT DEVICE DATA BLOCK
,AND ADVANCES THE BUFFER ADDRESS TO THE NEXT BUFFER IN THE RING.
,UPON RETURN. SKIPS IF THE NEXT BUFFER IS EMPTY.
,MONITOR INTERFACE
,	STORAGE:	6
,	SYMBOLS SET/USED:
,	    ACCUMULATORS:		DEVDAT  U
,				PDP     S/U
,				TAC     S/U
,	    DEVICE DATA BLOCK:	DEVIAD  S/U
,	    JOB BUFFER HEADER:	IOUSE   S/U
	INTERN ADVBFF
ADVBFF:	ADRCHK DEVIAD(DEVDAT)
	HRLZI TAC,IOUSE;	IOUSE:=1
	IORB TAC,@DEVIAD(DEVDAT)
	HRRM TAC,DEVIAD(DEVDAT); DEVIAD:=NEXT BUFFER ADDRESS
	SKIPL @DEVIAD(DEVDAT);	IOUSE=1?
	AOS (PDP);	EXIT2. NEXT BUFFER IS EMPTY
	POPJ PDP,;	EXIT1. NEXT BUFFER IS FULL

,DEC 06 00 EX COM L PT PRE 01 ASCIA
,C. FRAZIER AND W. SEGAL	64-12-26
,CALLING SEQUENCE
,	PUSHJ PDP,ASCIA
,	EXIT		ALWAYS RETURNS HERE
,ADDS THE ASCII INCREMENT (RIGHT JUSTIFIED) IN AC TAC1 TO THE FIVE
,DIGIT ASCII NUMBER (LEFT JUSTIFIED) IN AC TAC AND LEAVES THE 
,RESULT (LEFT JUSTIFIED) IN AC TAC.  TAC1 IS RESTORED.
,MONITOR INTERFACE
,	STORAGE:	21
,	SYMBOLS SET/USED:
,	    ACCUMULATORS:	PDP  U
,			TAC  S/U
,			TAC1 S/U

;	INTERN ASCIA
;ASCIA:	PUSH PDP,TAC1;	SAVE TAC1 = ASCII INCREMENT (RIGHT JUST
;	AND TAC1,K2;	CLEAR MOST SIGNIFICANT 3 BITS OF
;,			EACH CHARACTER
;	LSH TAC,-1;	TAC=FIVE DIGIT ASCII NO.(RIGHT JUST.)
;	IOR TAC,K4;	SET SECOND AND THIRD MOST SIGNIFICANT
;,			BITS OF EACH CHARACTER TO ONES.
;	TLZN TAC,400000
;	ADD TAC,K1
;	ADD TAC1,TAC
;	AND TAC1,K3
;	MOVE TAC,K4
;	AND TAC,TAC1
;	ASH TAC,-3
;	SUBM TAC1,TAC
;	IOR TAC,K4
;	LSH TAC,1
;	TRO TAC,1
;	POP PDP,TAC1;	RESTORE TAC1
;	POPJ PDP,;	RETURN
;K1:	OCT 215064321506;	CHARACTER MASK: 1000110
;K2:	OCT 036170743617;	CHARACTER MASK: 0001111
;K3:	OCT 176773757677;	CHARACTER MASK: 0111111
;K4:	OCT 140603014060;	CHARACTER MASK: 0110000

	INTERNAL ASSIN,ASSASG

ASSIN:	PUSHJ PDP,DEVSRC	;SEARCH FOR DEVICE
	POPJ PDP,		;DEVICE NOT FOUND
	MOVEI TAC1, ASSPRG	;DEVICE FOUND, FLAG AS ASSIGNED BY PROG

;ASSIGN DEVICE IF UNASSIGNED
;CALL:	MOVE ITEM, JOB NUMBER
;	MOVE DEVDAT, ADDR. OF DDB
;	MOVEI TAC1, EITHER ASSPRG OR ASSCON
;	PUSHJ PDP, ASSASG
;	CANT ASSIGN RETURN
;	ASSIGNED RETURN

ASSASG:	CONO APR,CLDS	;DISABLE CLOCK
	LDB TAC,PJOBN	;GET JOB NUMBER IN DEV DATA BLOCK
	CAMN TAC,ITEM	;IS IT ALREADY ASSIGNED TO THIS JOB
	JRST ASSAS1	;YES
	MOVEI TAC, ASSPRG+ASSCON	;NO, IS IT ASSIGNED TO ANOTHE
	CONO PI, SCNOFF	;TURN SCANNER OFF
	TDNE TAC, DEVMOD(DEVDAT)	;ARE EITHER ASSIGNED BITS SET
	JRST ASSAS2	;YES
	IORM TAC1, DEVMOD(DEVDAT)	;NO, SET ONE OF THEM
	DPB ITEM,PJOBN	;AND STORE JOB NUMBER
ASSAS1:	AOS (PDP)
ASSAS2:	CONO PI, SCNON	;TURN SCANNER BACK ON
	CONO APR,CLEN	;RENABLE CLOCK
	POPJ PDP,

;ROUTINE TO SEARCH FOR A DEVICE
;CALL:	HRR ITEM,JOB NUMBER
;	MOVE TAC,[SIXBIT .DEVICE NAME.]
;	PUSHJ PDP, DEVSRC
;	NOT FOUND
;	FOUND

	INTERNAL DEVLG,DEVSRC,DEVPHY
	EXTERNAL SYSTAP,DEVOPR

DEVSRC:	PUSHJ PDP, DEVLG	;SEARCH LOGICAL NAMES FIRST
	JRST DEVPHY	;NOT FOUND, SEARCH PHYSICAL NAMES
	JRST CPOPJ1	;FOUND

;SEARCH LOGICAL NAMES

DEVLG:	HLRZ DEVDAT,DEVLST	;BEGINNING OF DDB CHAIN
	JUMPE TAC,CPOPJ	;0 CANNOT BE A LOGICAL NAME
DEVLP0:	CAME TAC,DEVLOG(DEVDAT)	;COMPARE WITH LOGICAL NAME
	JRST DEV0		;NO MATCH
	LDB TAC1,PJOBN	;DOES THE LOGICAL NAME BELONG TO THIS J
	CAMN TAC1,ITEM
	JRST CPOPJ1		;YES
DEV0:	HLRZ DEVDAT,DEVSER(DEVDAT)	;NO, KEEP LOOKING
	JUMPN DEVDAT,DEVLP0
	POPJ PDP,		;FINISH AND NOT FOUND

;SEARCH PHYSICAL NAMES

DEVPHY:	JUMPE TAC,CPOPJ	;ZERO CANNOT BE A LOGICAL NAME
	CAMN TAC,[SIXBIT /OPR/] ;IS IT "OPR"?
	MOVE TAC,DEVOPR	;YES, CHANGE TO OPERATORS TTY
	CAMN TAC,[SIXBIT /SYS/] ;IS IT "SYS"?
	MOVE TAC,SYSTAP	;YES, CHANGE TO TO SYSTEM TAPE NAME
	HLRZ DEVDAT,DEVLST	;SEARCH DEVICE DATA BLOCKS
DEVLP1:	CAMN TAC,DEVNAM(DEVDAT)
	JRST CPOPJ1	;FOUND
	HLRZ DEVDAT,DEVSER(DEVDAT)
	JUMPN DEVDAT,DEVLP1
	POPJ PDP,	;NOT FOUND

,DEC 06 00 EX COM L PT PRE 01 BUFCLC
,H. R. MORSE	64-12-26
,CALLING SEQUENCE
,	PUSHJ PDP,BUFCLC
,	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
, SETS UP AN N BUFFER RING FOLLOWING THE USERS PROGRAM, WHERE N
, IS IN THE ADDRESS FIELD OF AC UUO.
, THE BUFFER RING FORMAT IS AS FOLLOWS:
,	LOCATION	LH   CONTENTS   RH
, C(JOBFF) + 1              BUFFER         C(JOBFF) +1
,    + 0(BUFFER SIZE+2)      SIZE               + 1(BUFFER SIZE+2)
, C(JOBFF) +1               BUFFER         C(JOBFF) +1
,     +1(BUFFER SIZE+2)      SIZE                + 2(BUFFER SIZE+2)
,         .		.		     .
,	.		.		     .
,	.		.		     .
, C(JOBFF) + 1	        BUFFER	   C(JOBFF) + 1
,    + (N-2)(BUFFER SIZE+2)  SIZE               +(N-1)(BUFFER SIZE+2)
, C(JOBFF) + 1	        BUFFER	   C(JOBFF) + 1
,    + (N-1)(BUFFER SIZE+2)  SIZE		
,THEN SET		BUFPNT:=IOUSE,C(JOBFF) + 1
, AND		JOBFF:=C(JOBFF) + 1 + N(BUFFER SIZE + 2)
, BUFWRD IS RESTORED.
,MONITOR INTERFACE
,	STORAGE:	20
,	ROUTINES CALLED:	ADRCK
,	SYMBOLS SET/USED:
,	    ACCUMULATORS:	BUFPNT  S/U	PROG   U
,			BUFWRD  S/U	TAC   S/U
,			DEVDAT  U		TAC1  S/U
,			PDP     S/U	UUO   U
,	DEVICE DATA BLOCK:	DEVCHR  U
,	JOB AREA:		JOBFF   S/U
,	JOB BUFFER HEADER:	IOUSE   U

	INTERN BUFCLC
BUFCLC:	PUSH PDP,BUFWRD;	SAVE BUFWRD ON STACK
	LDB TAC,[POINT 12,DEVCHR(DEVDAT),35];TAC:=BUFFER SIZE
	HRRZ BUFPNT,JOBFF(PROG);BUFPNT:=FIRST FREE LOCATION + 1
	ADDI BUFPNT,1
	HRRZ BUFWRD,BUFPNT
	HRLI BUFPNT,PROG
	HRL BUFWRD,TAC;	BUFWRD:=BUFFER SIZE,FIRST FREE LOC + 1
	ADDI TAC,2;	TAC:=BUFFER SIZE + 2
	HRRZ TAC1,UUO;	TAC1:=N=ADDRESS FIELD OF AC UUO
BUFC1:	ADD BUFWRD,TAC;	BUFWRD:=C(BUFWRD) + C(TAC)
	ADRCHK BUFPNT;	CHECK BUFFER FOR MEMORY BOUND
	MOVEM BUFWRD,@BUFPNT; BUFFER HEADER+1:=C(BUFWRD)
	HRR BUFPNT,BUFWRD;	BUFPNT 18-35:=C(BUFWRD 18-35)
	SOJG TAC1,BUFC1;	N:=N-1.  IS N>0?
	HRR BUFWRD,JOBFF(PROG)
	ADDI BUFWRD,1
	PUSHJ PDP,ADRCK	;CHECK LAST ADR. OF HEADER
	HRRZI TAC,-2(BUFPNT)
	SUB BUFPNT,TAC
	MOVEM BUFWRD,@BUFPNT;LINK LAST BUFFER TO FIRST BUFFER
	ADD BUFPNT,TAC
	HRRM BUFPNT,JOBFF(PROG);JOBFF:=C(JOBFF)+1+N(BUFFER SIZE+2)
	HRR BUFPNT,BUFWRD;	BUFPNT:=IOUSE,ADDRESS OF FIRST BUFFER
,			         IN RING.
	HRLI BUFPNT,IOUSE
	POP PDP,BUFWRD;	RESTORE BUFWRD FROM STACK.
	POPJ PDP,;	RETURN

,DEC 06 00 EX COM L PT PRE 01 BUFCLR
,H. R. MORSE	64-12-26
,CALLING SEQUENCE
,	PUSHJ PDP,BUFCLR
,	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
, CLEARS THE WORD COUNT AND DATA AREA OF THE BUFFER WHOSE ADDRESS
, IS IN TAC 18-35.
,MONITOR INTERFACE:
,	STORAGE:	13
,	ROUTINES CALLED:	ADRCK
,	SYMBOLS SET/USED:
,	    ACCUMULATORS:	PDP   U		TAC   S/U
,			PROG  U		TAC1  S/U
	INTERN BUFCLR
BUFCLR:	HRLI TAC,PROG
	ADRCHK TAC;	PROCEED IF CURRENT BUFFER ADDRESS
,			     < PROTECTION ADDRESS.
	HLRZ TAC1,@TAC;	TAC1 18-35=SIZE
	TRZ TAC1,400000
	ADD TAC1,TAC;	TAC1:=CURRENT BUFFER ADDRESS + SIZE
	ADRCHK TAC1;	PROCEED IF CURRENT BUFFER ADDRESS
,			     + SIZE < PROTECTION ADDRESS.
	MOVEI TAC,@TAC;	TAC:=CURRENT BUFFER ADDRESS+1,
,			     CURRENT BUFFER ADDRESS+1
	HRL TAC,TAC
	AOBJN TAC,.+1
	CLEARM 0(TAC);	WORD COUNT:=0
	AOS TAC		TAC:=CURRENT BUFFER ADDRESS+1,
,			     CURRENT BUFFER ADDRESS+2
	BLT TAC,@TAC1;	CLEAR BUFFER
	POPJ PDP,;	RETURN

	SUBTTL 5-17-65 PART 2

,CALLING SEQUENCE
,	PUSHJ PDP,CKS12
,	EXIT		ALWAYS RETURNS HERE
,CALCULATES FOLDED 12 BIT CHECKSUMS OF THE DATA WORDS IN THE
,BUFFER WHOSE ADDRESS IS IN AC TAC1.  TWO ALGORITHMS ARE USED.
,ON RETURN, THE LEFT HALF OF AC TAC CONTAINS A CHECKSUM OBTAINED
,BY ACCUMULATING, IN ONES COMPLEMENT, THE DATA WORDS AND FOLDING IT.
,THE LEFT HALF OF AC DAT CONTAINS A CHECKSUM OBTAINED BY ACCUMULATING
,IN TWOS COMPLEMENT, THE DATA WORDS AND FOLDING IT.  AC TAC1
,CONTAINS A 1.
,MONITOR INTERFACE
,	STORAGE:	20
,	ROUTINES CALLED:	FOLD
,	SYMBOLS SET/USED:
,	    ACCUMULATORS:	DAT   S/U		SUB   S
,			PDP   U		TAC   S/U
,			PROG  U		TAC1  S/U

	INTERN CKS12
CKS12:	ADD TAC1,PROG;	TAC1:=-WORD COUNT,ADDRESS OF FIRST DATA
	AOS TAC1
	HRRZ TAC,0(TAC1)
	MOVNS TAC
	AOS TAC1
	HRL TAC1,TAC
	CLEARM TAC;	INITIALIZE TWOS COMPLEMENT SUM
CKS12A:	ADD TAC,0(TAC1);	TWOS COMPLEMENT ADD
	AOBJN TAC1,CKS12A;	DONE?
FOLD:	LSHC TAC,-30
	LSH TAC1,-14
	ADD TAC,TAC1
	LSHC TAC,-14
	LSH TAC1,-30
	ADD TAC,TAC1
	TRZE TAC,770000
	AOS TAC
	HRLZS TAC
	MOVEI TAC1,1	;TAC1:=1
	POPJ PDP,

,DEC 06 00 EX COM L PT PRE 01 CLRBYT
,H. R. MORSE	64-12-26
,CALLING SEQUENCE 
,	PUSHJ PDP,CLRBYT
,	EXIT		ALWAYS RETURNS HERE
,CALLED WITH A BYTE POINTER IN AC TAC, IT CLEARS THE REST OF THE
,WORD POINTED TO BY THE BYTE POINTER.
,MONITOR INTERFACE
,	STORAGE:	7
,	SYMBOLS SET/USED:
,	    ACCUMULATORS:	PDP   U
,			TAC   U
,			TAC1  S/U
	INTERN CLRBYT
CLRBYT:	LDB TAC1,[POINT 6,TAC,5];	TAC1:=P
	DPB TAC1,[POINT 12,TAC,11];	TAC 0-5:=0,TAC 6-12:=P
	SETZM TAC1
	DPB TAC1,TAC;	CLEAR BITS 36-P THROUGH 35
	POPJ PDP,;	RETURN

;ROUTINE TO RELEASE ALL DEVICES ASSIGNED TO JOB

INTERNAL IORELS
EXTERNAL PUUOAC,RELEA3


IORELS:	MOVEI TAC,RELEA3	;RELEASE ALL IO DEVICES(DONT CLOSE)

;ROUTINE TO DO IO FOR ALL DEVICES ASSIGNED TO JOB
;CALL	MOVEI TAC,ADR. OR IO SUB.
;	PUSHJ PDP,IOALL

INTERNAL IOALL

IOALL:	PUSH PDP,TAC	;SAVE ADR. FO SUB.
	HRLZI DAT, -20
IOALL1:	MOVE DEVDAT, USRJDA(DAT)
	MOVE IOS,DEVIOS(DEVDAT)
	MOVEI UUO,0
	DPB DAT,PUUOAC
	SKIPE DEVDAT
	PUSHJ PDP,@(PDP)	;CALL THE SUB.
	AOBJN DAT, IOALL1
	POP PDP,TAC
	POPJ PDP,

;KILL ALL DEVICES(RELEASE WITHOUT WAITING FOR DEVICE INACTIVE)

INTERNAL IOKILL
EXTERNAL RELEA5

IOKILL:	MOVEI TAC,RELEA5
	JRST IOALL

,DEC 06 00 EX COM L PT PRE 01 IOSET
,H. R. MORSE	64-12-26
,CALLING SEQUENCE
,	PUSHJ PDP,IOSET
,	EXIT	ALWAYS RETURNS HERE
,THIS PROGRAM IS CALLED FROM AN INTERRUPT SERVICE ROUTINE.
,IT PUTS THE ADDRESS OF THE DATA AREA OF THE JOB (C(JBTADR18-35))
,CONNECTED TO THE DEVICE SPECIFIED BY AC DEVDAT IN AC PROG AND
,PUTS THE ITEM POINTER (C(DEVCTR)) IN AC ITEM.
,MONITOR INTERFACE
,	STORAGE:	5
,	SYMBOLS SET/USED:
,	    ACCUMULATORS:		DEVDAT U	PDP  U
,				ITEM   S	PROG S/U
,	    DEVICE DATA BLOCK:	DEVCHR U
,				DEVCTR U
,	    SYSTEM ADDRESSES:	JBTADR U
	INTERN IOSET

IOSET:	LDB PROG,PJOBN
	MOVE ITEM,DEVCTR(DEVDAT); ITEM:=ITEM POINTER=C(DEVCTR)
	HRRZ PROG,JBTADR(PROG);	PROG:=C(JBTADR 18-35)
	POPJ PDP,;		RETURN

,6-CSS-DEC-IOSETC-PL-PRE1
,H.R. MORSE   17-11-64

,CALLING SEQUENCE
,	PUSHJ PDP,IOSETC
,	EXIT		ALWAYS RETURNS HERE

,SETS JBFPTR18-35:=C(TAC1 18-35)
,	JBFCTR:=C(ITEM)*[WORD LENGTH/BYTE SIZE]
,WHERE	WORD LENGTH:=36 DECIMAL
,	BYTE SIZE:=C(JBFPTR6-11)
,	[X]:= INTEGER PART OF X

,MONITOR INTERFACE
,	STORAGE:	11
,	ROUTINES CALLED:	ITMCT1
,	SYMBOLS SET/USED:
,	    ACCUMULATORS:	JBUF S/U	TAC S/U
,			ITEM S/U	TAC1 S/U
,			PDP U

	INTERN IOSETC


IOSETC:	ADDI JBUF,1		;JBFPTR12-18:=0
	HRLZI TAC,7777	;JBFPTR18-35:=C(TAC1 18-35)+1
	ANDM TAC,@JBUF
	HRRM TAC1,@JBUF
	AOS @JBUF
	LDB TAC1,[POINT 6,@JBUF,11]	;TAC1:=BYTE SIZE
	PUSHJ PDP,ITMCT1	;JBFCTR:=C(ITEM)*[36/BYTE SIZE]
	ADDI JBUF+1
	MOVEM ITEM,@JBUF
	POPJ PDP,		;EXIT

,DEC 06 00 EX COM L PT PRE 01 ITMSET, ITMCNT, ITMCT1
,H.R. MORSE   64-12-26

,CALLING SEQUENCE
,	PUSHJ PDP,ITMSET
,	EXIT		ALWAYS RETURNS HERE
,SETS AC ITEM:=(BUFFER SIZE-1)*[WORD LENGTH/BYTE SIZE]
,WHERE BUFFER SIZE:=BITS 1-17 OF THE BUFFER HEADER WORD POINTED TO
,		BY C(DEVADR)
,	WORD LENGTH:=36 DECIMAL
,	BYTE SIZE:=INTEGER PART OF X.

,CALLING SEQUENCE
,	PUSHJ PDP,ITMCNT
,	EXIT		ALWAYS RETURNS HERE
,SETS AC ITEM:=C(ITEM)*[WORD LENGTH/BYTE SIZE]

,CALLING SEQUENCE
,	PUSHJ PDP,ITMCT1
,	EXIT		ALWAYS RETURNS HERE
,SETS AC ITEM:=C(ITEM)*[WORD LENGTH/C(TAC1)]

,MONITOR INTERFACE
,	STORAGE:	7
,	SYMBOLS SET/USED:
,	    ACCUMULATORS:	DEVDAT U	TAC S/U
,			ITEM S/U	TAC1 S/U
,			PDP U
,	DEVICE DATA BLOCK:	DEVADR U
,			DEVPTR U

	INTERN ITMSET,ITMCNT,ITMCT1
ITMSET:	LDB ITEM,[POINT 17,@DEVADR(DEVDAT),17];ITEM:=BUFFER SIZE-1
	SUBI ITEM,1
ITMCNT:	LDB TAC1,[POINT 6,DEVPTR(DEVDAT),11];TAC1:=BYTE SIZE
ITMCT1:	MOVEI TAC,44	;ITEM:=C(ITEM)*[WORD LENGTH/C(TAC1)]
	IDIV TAC,TAC1
	IMUL ITEM,TAC
	POPJ PDP,

;ROUTINE TO SET DEVICE STATUS WORD FROM UUO

INTERNAL SETIOS
EXTERNAL ILLMOD

SETIOS:	LDB TAC1,[POINT 4,UUO,35]	;GET DEVICE DATA MODE
	MOVEI TAC,1	;AND CHECK FOR LEGALITY
	LSH TAC,(TAC1)
	TDNN TAC,DEVMOD(DEVDAT)
	JRST ILLMOD	;ILLEGAL MODE
	TRZ UUO,IOACT	;LET USER SET ALL BITS EXCEPT IOACT
	HRRM UUO,DEVIOS(DEVDAT)
	POPJ PDP,

,DEC 06 00 EX COM L PT PRE 01 NEWBUF, BPNSET
,H. R. MORSE	64-12-26
,CALLING SEQUENCE
,	PUSHJ PDP,NEWBUF
,	EXIT		ALWAYS RETURNS HERE
,CLEARS THE BUFFER CURRENTLY POINTED TO BY THE INPUT BUFFER
,ADDRESS (DEVDR) OF THE CURRENT DEVICE.  SETS UP THE BYTE
,POINTER (DEVPTR), AND THE ITEM COUNT (DEVCTR) AND RETURNS.
,CALLING SEQUENCE
,	PUSHJ PDP,BPNSET
,	EXIT		ALWAYS RETURNS HERE
,SETS UP THE BYTE POINTER (DEVPTR) AND THE ITEM COUNT (DEVCTR)
,OF THE CURRENT DEVICE AND RETURNS.
,MONITOR INTERFACE
,	STORAGE:	10
,	ROUTINES CALLED:	BUFCLR, ITMSET
,	SYMBOLS SET/USED:	
,	    ACCUMULATORS:	DEVDAT  U		PDP  U
,			ITEM    U		TAC  S/U
,	    DEVICE DATA BLOCK:	DEVADR  U
,			DEVCTR  S
,			DEVPTR  S/U

	INTERN BPNSET,NEWBUF

NEWBUF:	HRRZ TAC,DEVADR(DEVDAT); TAC:=INPUT BUFFER HEADER ADDRESS
	PUSHJ PDP,BUFCLR;	CLEAR INPUT BUFFER.
BPNSET:	HRR TAC,DEVADR(DEVDAT)
	HRLZI TAC,7737
	AND TAC,DEVPTR(DEVDAT); DEVPTR 0-5:=0, DEVPTR 12:=0
	HRR TAC,DEVADR(DEVDAT); DEVPTR 18-35:=C(DEVADR 18-35) + 1
	AOS TAC
	MOVEM TAC,DEVPTR(DEVDAT)
	PUSHJ PDP,ITMSET;	ITEM:=(BUFFER SIZE-1)*[36/BYTE SIZE]
	MOVEM ITEM,DEVCTR(DEVDAT); DEVCTR:=ITEM COUNT
	POPJ PDP,;	RETURN

,DEC 06 00 EX COM L PT PRE 02 SETBYT
,H. R. MORSE	64-12-26
,CALLING SEQUENCE
,	PUSHJ PDP,SETBYT
,	EXIT		ALWAYS RETURNS HERE
,SETS	TAC 0-5:=0
,	TAC 6-11:=S
,	TAC 12-13:=0
,	TAC 14-17:=PROG
,WHERE S=35 IF DATA MODE (IOS 32-25) IS BINARY (B)
,      S=8  IF DATA MODE IS IMAGE (I)
,      S=7  IF DATA MODE IS	ASCII PACKED (A)
,			ASCII LINE (AL)
,			ASCII SEQUENCED (AS)
,			ASCII SEQUENCED LINE (ASL)
,		OR	ALTERNATE MODE BREAK (AM)
,MONITOR INTERFACE
,	STORAGE:	12
,	SYMBOLS SET/USED:
,	    ACCUMULATORS:	PROG  U		TAC   S
,			PDP   U		TAC1  S/U
,	    DEVICE DATA BLOCK:	DEVIOS U
	INTERN SETBYT
SETBYT:	MOVE TAC1,DEVIOS(DEVDAT);	FETCH DATA MODE, BITS 32-35 0
	ANDI TAC1,17
	CAIE TAC1,IB	;DATA MODE IMAGE BINARY?
	CAIN TAC1,B;	IS DATA MODE=BINARY?
	HRLI TAC,4400+PROG;	SET BYTE SIZE TO 36.
	CAIN TAC1,I;	IS DATA MODE=IMAGE?
	JRST SETBY1
	TRNE TAC1,14;	IS DATA MODE=ASCII PACKED,ASCII LINE,
	JRST .+2;		ASCII SEQUENCED,OR ASCII SEQUENCED LINE
	HRLI TAC,700+PROG;	SET BYTE SIZE TO 7.
	POPJ PDP,;	RETURN

SETBY1:	HLLZ TAC,DEVMOD(DEVDAT)
	TLZ TAC,770077
	TLO TAC,PROG
	POPJ PDP,

,DEC 06 00 EX COM L PT PRE 01 STORE ITEM
,H.R. MORSE	64-12-26
,CALLING SEQUENCE
,	PUSHJ PDP,STODAT
,	EXIT1		CHECKSUM ERROR
,	EXIT2		BLOCK FULL OR BLOCK COMPLETE
,	EXIT3		DATA STORED CORRECTLY
,CALLED FROM AN INPUT SERVICE ROUTINE WITH A DATA ITEM IN AC DAT.
,STORES THE DATA ITEM IN THE BUFFER, CHECKING TO SEE IF IT WERE
,THE FIRST ITEM ON THE BUFFER AND SETTING UP THE POINTER AND
,WORD COUNT APPROPRIATELY CHECKING THE MODE TO SEE IF ANY SPECIAL
,PROCESSING NEED BE DONE.  FOR EXAMPLE, GENERATION OF SEQUENCE
,NUMBERS PRECEDING EACH LINE IN SEQUENCE MODE, OR THE TERMINATION
,OF A BUFFER ON CERTAIN CHARACTERS IN OTHER MODES, OR IF THE BUFFER
,IS FULL.  THERE ARE THREE RETURNS FROM THIS ROUTINE: THE FIRST
,RETURN OCCURS ON AN ERROR CONDITION, THE SECOND RETURN OCCURS
,ON A BLOCK FULL CONDITION OR BLOCK COMPLETE CONDITION, THE THIRD
,RETURN OCCURS ON THE DATA STORED CORRECTLY CONDITION.  THIS
,ROUTINE ALSO DOES SOME CHECKING ON INPUT OF BINARY RECORD,
,PAPER TAPE OR CARDS.
,CALLING SEQUENCE
,	PUSHJ PDP,STOSQD
,	XXXX		ALWAYS SKIPS
,	EXIT		ALWAYS RETURNS HERE
,STORES THE WORD COUNT:=C(DEVPTR 18-35) -C(DEVIAD 18-35) - 1
,IN THE BUFFER.
,MONITOR INTERFACE
,	STORAGE:	69
,	ROUTINES CALLED: ASCIA, CKS12, ITMSET, NEWBUF
,	SYMBOLS SET/USED:
,	    ACCUMULATORS:		DAT    U	PDP  U
,				DEVDAT U	TAC S/U
,				IOS    S/U	TAC1 S/U
,				ITEM   S/U
,	    DEVICE DATA BLOCK:	DEVCTR U	DEVPTR S/
,				DEVIAD U	DEVSEQ S/
,	    IO STATUS WORD: A    U		I      U
,				AS   U		IOBKTL S
,				ASL  U		IODTER S
,				B    U		IOFST  S/
,	    JOB BUFFER AREA:	WORD COUNT S

	INTERN STODAT, STOSQD

STODAT:	TLNE IOS,IOFST;	WILL THE NEXT ITEM BE THE FIRST ITEM
,			   OF A BUFFER?
	PUSHJ PDP,NEWBUF;	SET UP A NEW BUFFER. ITEM:=(BUFFER
,			   SIZE - 1)*[36/BYTE SIZE]
	LDB TAC1,PIOMOD;	TAC1:=DATA MODE
	CAIN TAC1,B;	MODE=BINARY?
	JRST STOBIN
	TLZ IOS,IOFST
STO1:	DPBI DAT,DEVPTR(DEVDAT); STORE DATA IN BUFFER.
	CAIE TAC1,A;	MODE=ASCII, IMAGE, OR BINARY?
	CAIN TAC1,I
	JRST STOAIB
	CAIN TAC1,B
	JRST STOAIB
	CAIG DAT,214	;LINE FEED,FORM FEED, OR VERTICAL TAB?
	CAIGE DAT,212
	JRST .+2	;NO
	JRST STOSQD	;YES
	SOJGE ITEM,CPOPJ2;	ITEM:=C(ITEM)-1. IS C(ITEM)>OR=0?
STOE1:	TRO IOS,IOBKTL	;IOBKTL:=1
	JRST CPOPJ
STOAIB:	SOJG ITEM,CPOPJ2;	ITEM:=C(ITEM)-1. IS C(ITEM)>0?
	CAIN TAC1,A;	MODE=ASCII?
	JRST STOSQD
	CAIN TAC1,B;	MODE=BINARY?
	JRST STOBND
STOI:	PUSHJ PDP,ITMSET;	ITEM:=(BUFFER SIZE-1)*[36/BYTE SIZE]
,			       - C(DEVCTR)
	SUB ITEM,DEVCTR(DEVDAT)
	HRRZ TAC1,DEVIAD(DEVDAT)	;STORE ITEM COUNT INSTEAD OF
	ADDI ITEM,1	;IN FIRST WORD OF BUFFER
	AOJA TAC1,STOSQE

STOSQD:	MOVE TAC1,DEVIAD(DEVDAT); TAC1:=ADDRESS OF WORD COUNT
	AOS TAC1
	HRRZ ITEM,DEVPTR(DEVDAT); ITEM:=C(DEVPTR 18-25) -
,			        C(DEVIAD 18-35) -1
	SUB ITEM,TAC1
STOSQE:	HRRM ITEM,@TAC1	;WORD COUNT TO FIRST WORD IN BUFFER
	JRST CPOPJ1;	EXIT2. BLOCK COMPLETE
STOBIN:	TLZN IOS,IOFST;	WILL THE NEXT ITEM BE THE FIRST ITEM
	JRST STO1;	   OF A BUFFER?  IOFST:=0
	HRRZ TAC,DAT
	CAMLE TAC,ITEM;	IS WORD COUNT <OR= (BUFFER SIZE-1)*
	JRST STOE1;	   [36/BYTE SIZE]?
	MOVE ITEM,TAC;	ITEM:=WORD COUNT
	MOVEM DAT,@DEVPTR(DEVDAT); STORE WORD COUNT IN BUFFER
	JRST CPOPJ2;	EXIT3.  DATA STORED CORRECTLY.
STOBND:	HRRZ TAC1,DEVIAD(DEVDAT)
	PUSHJ PDP,CKS12;	COMPUTE CHECKSUM
	ADD TAC1, DEVIAD(DEVDAT)
	HLLZ TAC1,@TAC1;	DATA CHECKSUM=COMPUTED CHECKSUM?
	CAMN TAC,TAC1
	JRST CPOPJ1;	EXIT2. BLOCK COMPLETE
	TRO IOS,IODTER;	IODTER:=1
	JRST CPOPJ;	EXIT1.  CHECKSUM ERROR


,DEC 06 00 EX COM L PT PRE 01 UINTQ
,H.R. MORSE  64-12-26
,CALLING SEQUENCE
,     PUSHJ PDP, UINTQ
,     EXIT            ALWAYS RETURNS HERE
,TAC:=CONTENTS OF WORD FOLLOWING UUO CALL
,FROM USERS AREA.
,MONITOR INTERFACE
,     STORAGE: 4
,     SYMBOLS SET/USED:
,        ACCUMULATORS:  PDP U   TAC S/U
,                       PROG U
	INTERN UINTQ
UINTQ:	MOVE TAC, -1(PDP)		;TAC:=ADDRESS FOLLOWING UUO C
	HRLI TAC, PROG		;RELOCATE ADDRESS
	MOVE TAC, @TAC		;TAC:=CONTENTS OF WORD FOLLOW
				;UUO CALL FROM USERS AREA
	POPJ PDP,			;RETURN

	END,
